"""
This module contains all the Markov cross-validation method.

Classes
-------
MarkovCV

"""

from timecave.validation_methods._base import base_splitter
from timecave.data_characteristics import get_features
import warnings
import numpy as np
import pandas as pd
from typing import Generator
import matplotlib.pyplot as plt
import math


class MarkovCV(base_splitter):
    def __init__(self, ts: np.ndarray | pd.Series, p: int, seed: int = 1) -> None:
        self._check_seed(seed)
        self._check_p(p)

        if p % 3 == 0:
            self._m = math.floor(2 * p / 3) + 1
        else:
            self._m = math.floor(2 * p / 3) + 2

        self.n_subsets = (
            2 * self._m
        )  # total number of subsets (training + tests subsets)
        splits = 2 * self._m  # due to 2-fold CV
        super().__init__(splits, ts, 1)
        self._p = p
        self._seed = seed
        self._suo = {}
        self._sue = {}

    def _check_p(self, p: int) -> None:
        """
        Perform a type and value check on the p.
        """

        if isinstance(p, int) is False:

            raise TypeError("'p' should be an integer.")

        if p < 0:

            raise ValueError("'p' must be positive.")

        return

    def _check_seed(self, seed: int) -> None:
        """
        Perform a type check on the seed.
        """

        if isinstance(seed, int) is False:

            raise TypeError("'seed' should be an integer.")

        return

    @property
    def sampling_freq(self) -> int | float:
        """
        Get the time series' sampling frequency.

        This method can be used to access the time series' sampling
        frequency, in Hertz (this is set on intialisation).
        Since the method is implemented as a property, this information can
        simply be accessed as an attribute using dot notation.

        Returns
        -------
        int | float
            The time series' sampling frequency (Hz).
        """
        warnings.warn(
            "The training and tests sets generated by this method do not maintain a constant sampling rate.",
            UserWarning,
        )

        return None

    def _markov_iteration(self, n: int) -> np.array:
        np.random.seed(self._seed)

        d = np.zeros(n, dtype=int)

        i, j = 1, -1
        if np.random.rand() < 0.25:
            d[0], d[1] = i, i + 1
        elif np.random.rand() < 0.5:
            d[0], d[1] = i, j - 1
        elif np.random.rand() < 0.75:
            d[0], d[1] = j - 1, i
        else:
            d[0], d[1] = j - 1, j - 1

        for t in range(2, n):
            rd = np.random.rand()
            if (d[t - 1] > 0) and (d[t - 2] > 0):
                d[t] = j
                j -= 1
            elif (d[t - 1] < 0) and (d[t - 2] < 0):
                d[t] = i
                i += 1
            elif rd > 0.5:
                d[t] = j
                j -= 1
            else:
                d[t] = i
                i += 1

        return d

    def _markov_partitions(self):
        n = self._n_samples

        d = self._markov_iteration(n)

        Id = np.mod(d, self._m) + 1 + np.where(d > 0, 1, 0) * self._m

        Su = {}
        for u in range(1, 2 * self._m + 1):
            Su[u] = np.where(Id == u)[0]

        self._suo = {}
        self._sue = {}
        for u in range(1, self._m + 1):
            self._suo[u] = Su[u * 2 - 1]
            self._sue[u] = Su[u * 2]

    def split(self) -> Generator[tuple, None, None]:
        self._markov_partitions()
        for i in range(1, len(self._suo.items()) + 1):
            train, validation = self._suo[i], self._sue[i]
            yield (train, validation)
            train, validation = self._sue[i], self._suo[i]
            yield (train, validation)  # two-fold cross validation

    def info(self) -> None:
        self._markov_partitions()

        lengths = []
        for i in range(1, len(self._suo.items()) + 1):
            lengths.extend([len(self._suo[i]), len(self._sue[i])])

        print("Markov CV method")
        print("---------------")
        print(f"Time series size: {self._n_samples} samples")
        print(f"Number of splits: {self.n_splits}")
        print(f"Number of observations per set: {min(lengths)} to {max(lengths)}")
        pass

    def statistics(self) -> tuple[pd.DataFrame]:

        columns = [
            "Mean",
            "Median",
            "Min",
            "Max",
            "Variance",
            "P2P_amplitude",
            "Trend_slope",
            "Strength_of_trend",
            "Mean_crossing_rate",
            "Median_crossing_rate",
        ]

        if self._n_samples <= 2:

            raise ValueError(
                "Basic statistics can only be computed if the time series comprises more than two samples."
            )

        full_features = get_features(self._series, self._fs)[columns]
        training_stats = []
        validation_stats = []

        for training, validation in self.split():

            training_feat = get_features(self._series[training], self._fs)
            training_stats.append(training_feat[columns])

            validation_feat = get_features(self._series[validation], self._fs)
            validation_stats.append(validation_feat[columns])

        training_features = pd.concat(training_stats)
        validation_features = pd.concat(validation_stats)

        return (full_features, training_features, validation_features)

    def plot(self, height: int, width: int) -> None:

        fig, axs = plt.subplots(self.n_splits, 1, sharex=True)
        fig.set_figheight(height)
        fig.set_figwidth(width)
        fig.supxlabel("Samples")
        fig.supylabel("Time Series")
        fig.suptitle("Markov CV method")

        for it, (training, validation) in enumerate(self.split()):

            axs[it].scatter(training, self._series[training], label="Training set")
            axs[it].scatter(
                validation, self._series[validation], label="Validation set"
            )
            axs[it].set_title("Iteration {}".format(it + 1))
            axs[it].legend()

        plt.subplots_adjust(hspace=0.5)
        plt.show()

        return


if __name__ == "__main__":
    mcv = MarkovCV(ts=np.arange(50), p=1, seed=1)
    mcv.split()
    mcv.info()
    mcv.plot(2, 10)
    print()
